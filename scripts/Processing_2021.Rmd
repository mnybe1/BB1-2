---
title: "Processing_2021"
author: "Marion Nyberg"
date: "05/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, root.dir = '~/Google Drive/Micromet Lab/People/2019-Marion Nyberg/BB1-2')

library(caret)
library(leaps)
#library(MASS)
library(car)
library(dplyr)
library(plyr)
library(ggplot2)
library(lubridate)
library(naniar)
library(tidyr)
library(plotly)
library(knitr)
library(data.table)
library(kableExtra)
library(ggsci)
library(effects)
library(broom)
library(jtools)

rm(list=ls())
```

```{r set working directory and load data}
wd <- '~/Google Drive/Micromet Lab/People/2019-Marion Nyberg/BB1-2'
setwd(wd)

Env.input_file <- "data/Full.csv" #All data (GS and NGS), below 2 new data frames separated into GS and NGS
Env.input_data <- read.csv(Env.input_file) 

ind.GS <- (Env.input_data$jday >= 92 & Env.input_data$jday <= 274)
ind.NGS <- (Env.input_data$jday < 92 | Env.input_data$jday >=275)
```

## {.tabset .tabset-fade}

### To do

These results are accompanied with somewhat rambling thoughts trying to figure out what's going on. 

- Need to decide whether using nighttime or day time partitioned CO2 fluxes (I think Night?). Using RF gf for CH4

- PARin
  - BB1 is still higher than BB2 even after the corrections I put in place over the summer. But so is SWradin so maybe it makes some sense...? 
  
  
- Calculate __radiative forcing__ - have gotten some values from K. Nugents code, although still trying to figure out how to make it predict over time... I think what I have now is the radiative forcing currently... I have a value of ~ -3 for total RF (CO2 and CH4)
  - Need a natural wetland GHG budget to use as reference? - see Petrescu et al. 2015 & Nugent et al. 2018
  

- Add in __statistical analysis__
  - Spearmans rank correlation (Helfter et al 2015)

- calculate __Q10s__. 

- check about when to use GF/non GF co2 and ch4 fluxes

- __HYSTERESIS__ - if focusing more on WTH as diff between the sites. - effect on Reco and CH4..
  - could create index that splits the year into different stages, e.g. early GS, late GS, non GS...
  
  
- __UNCERTAINTY__


_Later list:_
- Diurnal  variation? 
- Seasonal drivers? look more at end or see if ER or GPP at one site and specific season is driving it more or less.



### Environmental variables

__Air temperature__

```{r Air temperature, fig.width=10, fig.height=4}
Ta.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), Ta_mean)) + #as.Date adds the month names into the plot
  #geom_ribbon(aes(ymin = Ta_min -1 , ymax = Ta_max+1), fill = "light grey")+
    geom_line(aes (color=Site)) +
   ylab("Air temperature (deg C)")+
  xlab("Month") +
   #ggtitle("Air temperature at BB1 and BB2")+
   scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
ggplotly(Ta.p)

kruskal.test(Ta_mean~Site, data = Env.input_data)
```

__Relative humidity__

```{r Relative humidity, fig.width=10, fig.height=4}
RH.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), RH_mean)) + #as.Date adds the month names into the plot
  #geom_ribbon(aes(ymin = RH_min -1 , ymax = RH_max +1), fill = "light grey")+
    geom_line(aes (color=Site)) +
   ylab("Relative humidity (%)")+
  xlab("Month") +
   #ggtitle("Air temperature at BB1 and BB2")+
   scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
ggplotly(RH.p)

kruskal.test(RH_mean~Site, data = Env.input_data)
```

__Water table height__

```{r Water table height, fig.width=10, fig.height=4}
WTH.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), WTH._mean)) + #as.Date adds the month names into the plot
  #geom_ribbon(aes(ymin = WTH._min -1 , ymax = WTH._max+1), fill = "light grey")+
    geom_line(aes (color=Site)) +
   ylab("Water table height (cm)")+
  xlab("Month") +
   #ggtitle("Air temperature at BB1 and BB2")+
   scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
ggplotly(WTH.p)

kruskal.test(WTH._mean~Site, data = Env.input_data)
```

__5cm soil temperature__

```{r T5cm Soil temperature, fig.width=10, fig.height=4}
TS.5.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), TS.5_mean)) + #as.Date adds the month names into the plot
  #geom_ribbon(aes(ymin = TS.5_min -1 , ymax = TS.5_max+1), fill = "light grey")+
    geom_line(aes (color=Site)) +
   ylab("5cm soil temperature (deg C)")+
  xlab("Month") +
   #ggtitle("Air temperature at BB1 and BB2")+
   scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
ggplotly(TS.5.p)

kruskal.test(TS.5_mean~Site, data = Env.input_data)
```

__10cm soil temperature__

```{r T10cm Soil temperature, fig.width=10, fig.height=4}
TS.10.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), TS.10_mean)) + #as.Date adds the month names into the plot
  #geom_ribbon(aes(ymin = TS.5_min -1 , ymax = TS.5_max+1), fill = "light grey")+
    geom_line(aes (color=Site)) +
   ylab("10cm soil temperature (deg C)")+
  xlab("Month") +
   #ggtitle("Air temperature at BB1 and BB2")+
   scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
ggplotly(TS.10.p)

kruskal.test(TS.10_mean~Site, data = Env.input_data)
```

__Precipitation__

Notes:
- No Env Can precip data at nearby weather station for start of 2020

- 10 year average data presented below

```{r Precipitation}
library(reshape2)
#Load Environment Canada precipitation data and re-format:
EC_precip <- read.csv('/Users/marionnyberg/Google\ Drive/Micromet\ Lab/People/2019-Marion\ Nyberg/BB1-2/data/EC_precip2021.csv') 
EC_precip$Timestamp <- as.POSIXlt(EC_precip$Timestamp, format = "%Y-%m-%d")
EC_precip$month <- months(EC_precip$Timestamp, abbreviate = TRUE)
EC_precip <- EC_precip %>%
   select(c(month, jday, Site, Precip_mean)) %>%
  group_by(month) %>%
  mutate(Cumsum = cumsum(Precip_mean))


#cs <- cumsum(x)
#cs[miss] <- NA
#Precip data frame has the daily total
Precip <- read.csv('/Users/marionnyberg/Google\ Drive/Micromet\ Lab/Projects/2014-Burns\ Bog/Flux-tower/met_data/cr1000/BBPCT.csv') 
miss <- is.na(Precip)
Precip[miss] <- 0
Precip$Time..PST. <- as.POSIXlt(Precip$Time..PST., format = "%Y-%m-%d")
Precip$month <- months(Precip$Time..PST., abbreviate = TRUE)
Precip$year <- year(Precip$Time..PST.)
Precip$jday <-yday(Precip$Time..PST.)
Precip <- Precip %>% filter(year == '2020')
Precip.cumsum <- Precip %>% group_by(month) %>%
  mutate(BB1 = cumsum(Precipitation..1.00m.),
         BB2 = cumsum(BB2.Precipitation..1.00m.))
Precip.cumsum <- Precip.cumsum %>% select(month, jday, BB1, BB2) %>%
  melt(id.vars = c("month", "jday"),
       variable.name = "Site",
       value.name = "Cumsum.Precip")

names(Precip)[2] <- "BB1"
names(Precip)[3] <-"BB2"

#Precip.2 df has the daily average rainfall, therefore it needs to be multiplied by 48(measurements taken every 30 mins)
Precip.2 <- Precip %>% select(c(month, jday, BB1, BB2))%>%
  melt(id.vars = c("month", "jday"),
       variable.name = "Site",
       value.name = "Precip")

Precip.2 <- Precip.2 %>% 
  ddply(c("Site", "month", "jday"), summarize,
        Precip_mean = (mean(Precip)*48)) %>%
  group_by(Site, month) %>%
  mutate(Cumsum = cumsum(Precip_mean))



#Precip <- Env.input_data %>% 
 #  select(Precip_mean, Site, jday, month) %>%
  # group_by(Site, month) %>%
   #mutate(Precip_mean = Precip_mean*10) %>%
   #full_join(., EC_precip) %>%
  #group_by(Site, month) %>%
  # mutate(Precip.cumsum = cumsum(Precip_mean))

#Precip <- Env.input_data %>% 
 #  select(Precip_mean, Site, jday, month) %>%
  # group_by(Site, month) %>%
  #summarise(Precip = (cumsum(Precip_mean) * 10))

#P.p <- ggplot(Precip.cumsum, aes(month, Cumsum.Precip, fill = Site)) + 
 # geom_col(position = 'dodge') +
  # scale_x_discrete(limits = month.abb) +
  #ylab("Precipitaion (mm)")+
   #scale_fill_aaas()+
  #theme_bw()
#ggplotly(P.p)

Precip.3 <- Precip.2 %>%
  full_join(., EC_precip) %>%
  group_by(Site, month)

P.p2 <- ggplot(Precip.3, aes(month, Cumsum, fill = Site)) + 
  geom_col(position = 'dodge') +
   scale_x_discrete(limits = month.abb) +
  ylab("Precipitaion (mm)")+
   scale_fill_aaas()+
  theme_bw()
ggplotly(P.p2)

```


__SW in__


```{r Incoming SW radiation, fig.width=10, fig.height=4}
(Env.input_data  %>%
   ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), SWin_mean)) + 
  geom_line(aes(color = Site))) +
  ylab("Incoming SW raditation (W m-2 day-1)")+
  xlab("Month")+
     scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
```


__PAR__

```{r PARin, fig.width=10, fig.height=4, message=FALSE, warning = FALSE}
(Env.input_data %>%
   ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), PARin_mean)) + 
  geom_line(aes(color = Site))) +
  ylab("Incoming SW raditation (W m-2 day-1)")+
  xlab("Month")+
     scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw()
```

__NDVI__

Notes: 
- Checked both a lienar and a spline fit - spline fit filled til the end of the year at seemed to fit the data better so going to go with that. Maybe should use linear? 

```{r load NDVI data and gap fill, figures-side, fig.show="hold", out.width="50%"}
NDVI1 <- read.csv('/Users/marionnyberg/Google\ Drive/Micromet\ Lab/People/2019-Marion\ Nyberg/BB_ndvi/bb1_ndvi.csv')
NDVI1$Site <- 'BB1'
ind <- which(NDVI1$system.time_start == '13-Jul-20')
NDVI1$NDVI[ind] <- NA
NDVI2 <- read.csv('/Users/marionnyberg/Google\ Drive/Micromet\ Lab/People/2019-Marion\ Nyberg/BB_ndvi/bb2_ndvi.csv')  
NDVI2$Site <- 'BB2'
NDVI <- full_join(NDVI1, NDVI2)
NDVI$DATE <- dmy(NDVI$system.time_start)

NDVI$jday <- yday(NDVI$DATE)
NDVI <- NDVI %>%
  select(c(jday, Site, NDVI, DATE))


NDVI.p <- ggplot(NDVI, aes(DATE, NDVI)) + 
  geom_line(aes (color = Site)) +
    scale_x_date(date_breaks = "2 weeks") +
   scale_color_aaas()+
  theme_bw()+ 
    theme(axis.text.x = element_text(angle = 90))

BB1.NDVI <- NDVI %>% filter(Site == "BB1") %>% select(DATE, NDVI, Site)
ApproxFun <- approxfun(x = BB1.NDVI$DATE, y = BB1.NDVI$NDVI)
Dates <- seq.Date(ymd("2020-01-01"), ymd("2020-12-31"), by = 1)
LinearFit <- ApproxFun(Dates)
BB1 <- as.numeric(LinearFit)
BB1.linear <- as.data.frame(BB1)

SplineFun <- splinefun(x = BB1.NDVI$DATE, y = BB1.NDVI$NDVI)
SplineFit <- SplineFun(Dates)
#summary(SplineFit) #Use spline fit I think to gapfill
BB1 <- as.numeric(SplineFit)
BB1.spline <- as.data.frame(BB1)     # use spline because it does the whole year                
BB1.spline$Site <- "BB1"
BB1.spline$jday <- c(1:366)
names(BB1.spline)[1] <- "SplineFit"

plot(BB1.NDVI$DATE, y = BB1.NDVI$NDVI, ylim = c(0.3, 0.8))
lines(Dates, SplineFit, col = "red")
lines(Dates, LinearFit, col = "blue")   

BB2.NDVI <- NDVI %>% filter(Site == "BB2") %>% select(DATE, NDVI, Site)
ApproxFun <- approxfun(x = BB2.NDVI$DATE, y = BB2.NDVI$NDVI)
Dates <- seq.Date(ymd("2020-01-01"), ymd("2020-12-31"), by = 1)
LinearFit <- ApproxFun(Dates)
BB2 <- as.numeric(LinearFit)
BB2.linear <- as.data.frame(BB2)

SplineFun <- splinefun(x = BB2.NDVI$DATE, y = BB2.NDVI$NDVI)
SplineFit <- SplineFun(Dates)
BB2 <- as.numeric(SplineFit)
BB2.spline <-as.data.frame(SplineFit)
BB2.spline$Site <- "BB2"
BB2.spline$jday <- c(1:366)

plot(BB2.NDVI$DATE, y = BB2.NDVI$NDVI, ylim = c(0.3, 0.8))
lines(Dates, SplineFit, col = "red")
lines(Dates, LinearFit, col = "blue") 

NDVI.new <- full_join(BB1.spline, BB2.spline)
names(NDVI.new)[1] <- "NDVI_sf"

Env.input_data <- left_join(Env.input_data, NDVI.new)
```

```{r}
(NDVI.p <- ggplot(Env.input_data, aes(x = as.Date(jday, origin = as.Date("2020-01-01")), NDVI_sf)) + 
 geom_line(aes(colour = Site)) +
  ylab("NDVI")+
  xlab("Month") +
    scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  ggtitle("") +
   scale_color_aaas()+
  theme_bw())
```


__Compare to nearby weather station (Burns Bog) 10 year average data (from Env. Canada)__

 - Wetter than the 10 year average in 2020
 
 - need to create table that shows how much BB average monthly temperature and rainfall deviate from EC 10 year average

```{r compre env Can 10 year average to 2020 BB, fig.width=10, fig.height=4}
EC.avg <- read.csv('/Users/marionnyberg/Google\ Drive/Micromet\ Lab/People/2019-Marion\ Nyberg/BB1-2/EC_precip/EC_climate.csv') #10 years of Env.Can data from 2011-2020

EC.avg$Timestamp <- as.POSIXct(EC.avg$Timestamp, format = "%Y-%m-%d")
EC.avg$jday <- yday(EC.avg$Timestamp)

EC.temp.avg <- EC.avg %>% dplyr::select(jday, Month, Temp) %>%
  ddply(c("jday", "Month"), summarise,
        Ta_mean = mean(Temp, na.rm = TRUE)) 
EC.temp.avg$Site <- "EC"
names(EC.temp.avg)[2] <- "month"
EC.temp.avg$month <-month.abb[EC.temp.avg$month]

Temp.avg <- Env.input_data %>% select(Site, jday, Ta_mean, month) %>%
  full_join(EC.temp.avg)

Ta.p <- ggplot(Temp.avg, aes(jday, Ta_mean)) + 
 geom_line(aes(colour = Site)) +
  ylab("Air temperature (deg C)")+
  xlab("Julian DOY") +
  ggtitle("Air temperature for BB1, BB1 and the 10 year average from EC") +
   scale_color_aaas()+
  theme_bw()
ggplotly(Ta.p)

#TA.avg.p <- Temp.avg %>% ddply (c("month", "Site"), summarise,
 #                               MeanTemp = mean(Ta_mean)) %>%
#ggplot(., aes(month, MeanTemp, fill = Site))+
 # geom_col(position = 'dodge')+  
  #scale_x_discrete(limits = month.abb) +
   # scale_fill_aaas()+
  #theme_bw()
#ggplotly(TA.avg.p)

EC.Precip.avg <- EC.avg %>% dplyr::select(jday, Month, Precip) %>%
  ddply(c("jday", "Month"), summarise,
       Precip_mean = mean(Precip, na.rm = TRUE)) %>%
  group_by(Month) %>%
  mutate(Precip_cumsum = cumsum(Precip_mean))

names(EC.Precip.avg)[2] <- "month"
names(EC.Precip.avg)[4] <- "Cumsum"
EC.Precip.avg$Site <- "EC"
EC.Precip.avg$month <-month.abb[EC.Precip.avg$month]

Precip.avg <- Precip.2 %>% select(Site, jday, Cumsum, Precip_mean, month) %>%
  full_join(EC.Precip.avg)

Precip.p <- ggplot(Precip.avg, aes(month, Cumsum, fill = Site)) + 
  geom_col(position = 'dodge') +
   scale_x_discrete(limits = month.abb) +
  ylab("Precipitaion (mm)")+
   scale_fill_aaas()+
  theme_bw()
ggplotly(Precip.p)
```

### CO2 and CH4 balance


```{r read in daily mean CO2 and CH4 fluxes}
setwd(wd)

# This file has daily averaged gap filled data
Flux.input_file <- "data/flux.csv" 
Flux.input_data <- read.csv(Flux.input_file)

Flux.ind.GS <- Flux.input_data[(Flux.input_data$jday >= 92 & Flux.input_data$jday <= 274), ] 
Flux.ind.NGS <-Flux.input_data[(Flux.input_data$jday < 92 | Flux.input_data$jday >=275), ] 
```

__Cumulative NEE__

By the end of 2020, BB1 was a CO2 sink, but BB2 was a source of CO2 to the atmosphere. Despite higher GPP at BB2, ER is also much greater, which is leading to it acting as a CO2 source. When only considering CO2, this is not an effective management strategy, or it is at a stage in it's recovery trajectory where it is a source of CO2 to the atmosphere.

- Daily mean cumulative NEE  (gC m-2 day-1)
- Using daily averages of NEEgC_f values
- CUP - how does this differ between the sites? 
- When comparing this to Nick's data from June 2015- June 2016 ~ -179 g CO2 C, the sink strength of BB1 in 2020 was -59 g CO2. This is nearly 1/3 of what is was 3 years previously. (need to look at environmental conditions)

```{r Cumulative NEE}
(NEEcum.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), NEEcum, color = Site)) +
  geom_line(aes(color = Site))+
  ylab(bquote('Cumulative NEE (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
    scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw())

#To make a table showing final values:
Flux.input_data %>%
  dplyr::select(c(Site, NEEcum, jday)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = NEEcum) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "Total NEE") %>%
  kable_classic(html_font = "Cambria")

kruskal.test(NEEcum ~ Site, data = Flux.input_data)

(NEE.time.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), NEEgC_f, color = Site)) +
  geom_line(aes(color = Site))+
  ylab(bquote('Cumulative NEE (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
    scale_x_date(date_breaks = "1 month", date_labels = "%b") +
   scale_color_aaas()+
  theme_bw())

```

__Cumulative GPP__

```{r Cumulative and timeseries GPP}
(GPPcum.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), GPPcum_f, color = Site)) +
  geom_line()+
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('Cumulative GPP (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
     scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    scale_color_aaas()+
  theme_bw())

Flux.input_data %>%
  dplyr::select(c(Site, GPPcum_f, jday)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = GPPcum_f) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "Total GPP") %>%
  kable_classic(html_font = "Cambria")

kruskal.test(GPPcum_f ~ Site, data = Flux.input_data)

(GPP.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), GPP_f, color = Site)) +
  geom_line()+
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('GPP (g C' ~m^-2~ day^-1*')'))+
  xlab("Julian dat of year")+
     scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    scale_color_aaas()+
  theme_bw())
```

__Ecosystem respiration__

- When does Reco peak at each site? It seems to peak earlier at BB1 than BB2. Is there evidence of rhizosphere priming? Is it sustained? 

```{r Cumulative and timeseries ER}
(Recocum.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), Recocum, color = Site)) +
  geom_line()+
    #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('Cumulative ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
 scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    scale_color_aaas()+
 theme_bw())#+
  #theme(legend.position = "none")

Flux.input_data %>%
  dplyr::select(c(Site, Recocum, jday)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = Recocum) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "Total REco") %>%
  kable_classic(html_font = "Cambria")

kruskal.test(Recocum ~ Site, data = Flux.input_data)

(Reco.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), Reco, color = Site)) +
  geom_line()+
    #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('Ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
 scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    scale_color_aaas()+
 theme_bw())
```


__CH4 flux__

CH4 flux is higher at BB1 than BB2, but how does this affect the annual GHG budget? 
- Nick calc CH4 budget 2016-2017 to be ~17 g CH4 - C, whereas in 2020 it was around 12 g CH4 - C.

```{r CH4 flux}
(CH4cum.p <-Flux.input_data %>% 
  ggplot(., aes(x = as.Date(jday, origin = as.Date("2020-01-01")), CH4cum_f_RF_gC, color = Site)) +
  geom_line()+
    #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('Cumulative' ~CH[4]~ 'flux (g C' ~m^-2~ day^-1*')'))+
  xlab("Month")+
     scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    scale_color_aaas()+
  theme_bw())

Flux.input_data %>%
  dplyr::select(c(Site, CH4cum_f_RF_gC, jday)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = CH4cum_f_RF_gC) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "Total CH4 flux (g C m-2 day-1") %>%
  kable_classic(html_font = "Cambria")

kruskal.test(CH4cum_f_RF_gC ~ Site, data = Flux.input_data)
```

### GHG budget

```{r calculating CO2 equivalents}
GWPCH4.20 <- 84 
GWPCH4.100 <- 28 # no feedback
SGWPCH4.100 <- 45
SGWPCH4.20 <- 96

CO2eq <- Flux.input_data %>% 
  group_by(Site,month_local) %>%
  summarise(NEE = sum(NEEgC_f),
            CH4 = sum(CH4gC_f_RF)) %>%
  mutate(CO2_CH4eq100 = GWPCH4.100 * (CH4 * (16.04/12.01)),
         CO2_CH4eq20 = GWPCH4.20 * (CH4 * (16.04/12.01)),
         CH4_CH4 = (CH4 * (16.04/12.01)),
         CO2_CO2eq = NEE * (44.01/12.01),
         SGWP100CH4 = SGWPCH4.100 * (CH4 * (16.04/12.01)),
         SGWP20CH4 = SGWPCH4.20 * (CH4 * (16.04/12.01))) %>%
  mutate(GHG_eq100 = CO2_CH4eq100 + CO2_CO2eq,
         GHG_eq20 = CO2_CH4eq20 + CO2_CO2eq) %>%
  group_by(Site) %>%
  mutate(total.20yrGHG = cumsum(GHG_eq20),
         total.100yrGHG = cumsum(GHG_eq100),
         cumCO2 = cumsum(CO2_CO2eq),
         cumch4 = cumsum(CH4_CH4),
         cumCH420yr = cumsum(CO2_CH4eq20),
         cumCH4100yr = cumsum(CO2_CH4eq100),
         SGWPcumCH4100yr = cumsum(SGWP100CH4),
         SGWPcumCH420yr = cumsum(SGWP20CH4),
         cumCH4gC20yrSGWP = cumsum(CH4)*SGWPCH4.20,
         cumCH4gC100yrSGWP = cumsum(CH4)*SGWPCH4.100) %>%
  mutate(cumNEESGWP = cumsum(NEE) - cumsum(CH4))%>%
  mutate(cumNEECO2 = cumNEESGWP *(44.01/12.01)) %>%
  mutate(SGWPtotal20 = cumNEECO2 + cumCH4gC20yrSGWP) %>%
  mutate(SGWPtotal100 = cumNEECO2 + cumCH4gC100yrSGWP)


#The rest of this chunk write csv files that are sued to calculate radiative forcing in the script from K.Nugent
BB1.RF <- CO2eq %>%
  filter(Site == "BB1") %>%
  select(c(cumCO2, cumch4)) %>%
  slice_tail() %>%
  summarise(cumCO2kg = cumCO2 / 100,
            cumch4kg = cumch4 /100)

write.csv(BB1.RF, "~/Google Drive/Micromet Lab/People/2019-Marion Nyberg/BB1-2/peat_RF_model_input_files/BB1_restored.csv")
 

BB2.RF <- CO2eq %>%
  filter(Site == "BB2") %>%
  select(c(cumCO2, cumch4))  %>%
  slice_tail()%>%
  summarise(cumCO2kg = cumCO2 / 100,
            cumch4kg = cumch4 /100)


write.csv(BB2.RF, "~/Google Drive/Micromet Lab/People/2019-Marion Nyberg/BB1-2/peat_RF_model_input_files/BB2_restored.csv")

```

__SGWP__

On both a 20 and 100 year timescale, both sites act a net source of warming to the atmosphere. On a 20 year timescale, the higher CH4 emissions at BB1, coupled with being a CO2 sink, lead to the site having a greater warming effect. However, on a 100 year timescale, BB2 has a much greater warming effect. This suggests that over a longer timescale, if the site is a CO2 sink (BB1), having higher CH4 emissions will not offset the CO2 sink potential.
 - On a short timescale, it is more important to have low CH4 emissions
 - On a long timescale, it is more important to be a CO2 sink

```{r SGWP}
CO2eq %>%
  dplyr::select(c(Site, SGWPtotal20, month_local)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = SGWPtotal20) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "20yr SWGP") %>%
  kable_classic(html_font = "Cambria")

CO2eq %>%
  dplyr::select(c(Site, SGWPtotal100, month_local)) %>%
  group_by(Site) %>%
  mutate(row = row_number()) %>%
  pivot_wider(names_from = Site, values_from = SGWPtotal100) %>%
  summarise(BB1 = last(na.omit(BB1)),
            BB2 = last(na.omit(BB2))) %>%
  kbl(caption = "100yr SWGP") %>%
  kable_classic(html_font = "Cambria")
```

### Environmental effects on CO2 fluxes

```{r join flux and environmental data}
setwd(wd)
library(broom)

NGFflux.input_file <- "data/BB_fulldata.csv"
NGFflux.input_data <- read.csv(NGFflux.input_file) %>%
  select(c("Site", "jday", 39:48, ))

Flux.Env <- right_join(Flux.input_data, Env.input_data,  by = c("jday", "Site")) %>%
   select(-c("TS.30_mean", "TS.30_min", "TS.30_max", "X.x", "X.y", "month_local")) %>% #remove unnecessary variables
   right_join(NGFflux.input_data, by = "jday", "Site") %>%
  rename(Site = Site.x)

Final.output_file <-"data/Final.csv"
write.csv(Flux.Env, Final.output_file)
```


__Ecosystem respiration and soil temperature__

For any given soil temperature, respiration is higher at BB2 than BB1.

- Night time gapfilled data

- At BB1, WTH is not a sig important predictor for REco (P= 0.09), however, at BB2, WTH is sig, important in predicting REco (P<0.01). This is because BB2 gets significantly drier, and so dry and warm soil temperatures --> increased respiration rates.

- The relationship look non-linear, so I will use polynomial regression to find which relationship is best for each site.

- Is there a point in calculating Q10s if WTH is such an important driver? 
  - Should calculate Q10s.

```{r Reco and Temp and WTH effect , figures-side, fig.show="hold", out.width="50%"}
#NOTES:
#Compare GS vs. Non GS - could compare the magnitude of difference to see if there is a particular time of year when the influence is higher

(ER.TS5.P <- Flux.Env %>%
  #filter(TS.5_mean > '0') %>%
  ggplot(., aes(TS.5_mean, RecogC, color= Site)) +
       scale_color_aaas()+
   xlab('5cm Soil temperature (deg C)')+
   ylab(bquote('Ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
  geom_point()+
   ggtitle("Reco ~ Soil temp")+
  theme_bw())

(ER.TS5.P <- Flux.Env %>%
  #filter(TS.5_mean > '0') %>%
  ggplot(., aes(WTH._mean, RecogC, color= Site)) +
       scale_color_aaas()+
   xlab('WTH(cm)')+
   ylab(bquote('Ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
    ggtitle("Reco ~ WTH")+
  geom_point()+
  theme_bw())
```




```{r split BB1 and BB2 data 1st time}
BB1 <- Flux.Env %>%
  filter(Site == "BB1")

BB2 <- Flux.Env %>%
  filter(Site == "BB2")
```
 

__BB1__ 

Calculate Q10 for ecosystem respiration. 

```{r BB1 Reco Q10}
Temp.Reco.BB1 <- lm(RecogC~TS.5_mean, data = BB1)
summary(Temp.Reco.BB1)
```


For BB1, 2 models to predict Reco were very similar (model 4(with WTH) and model 7). Thinking of going with model 7, which doesn't include WTH. Within sites, how important is WTH in explaining Reco? Need to check model assumptions. Including water table height does not sig improve (0.09) model. Therefore Reco at BB1 is predominately driven by temperature, and not WTH.

```{r BB1 model reln between Reco and Temp and WTH}
# Polynomial regression: Check for non-linear relationships #http://www.sthda.com/english/articles/40-regression-analysis/162-nonlinear-regression-essentials-in-r-polynomial-and-spline-regression-models/

# Build the models
model.1 <- lm(RecogC~ poly(TS.5_mean, 3, raw = TRUE), data = BB1)
model.2 <- lm(RecogC~ poly(TS.5_mean, 2, raw = TRUE), data = BB1)
model.3 <- lm(RecogC~ TS.5_mean, data = BB1)
model.4 <- lm(RecogC~ TS.5_mean + I(TS.5_mean^3) + WTH._mean, data = BB1) # Model with highest R2, only slightly higher than model without WTH (model 7)., but WTH isn't actually a significant predictor so will use model 7
model.5 <- lm(RecogC ~ log(TS.5_mean), data = BB1)
model.6 <- lm(log(RecogC) ~ TS.5_mean, data = BB1)
model.7 <- lm(RecogC~ TS.5_mean + I(TS.5_mean^3), data = BB1)  # use this model 


#summary(model.7)
#summary(model.4)
#summ(model.4)
#summ(model.7)  # need to check if ols is meeting assumptions

anova(model.7,model.4)

set.seed(123)
training.samples <- BB1$RecogC %>%
  createDataPartition(p = 0.8, list = FALSE)
train.data  <- BB1[training.samples, ]
test.data <- BB1[-training.samples, ]

# Make predictions
predictions <- model.7 %>% predict(test.data)

# Model performance
#data.frame(
 # RMSE = RMSE(predictions, test.data$RecogC),
  #R2 = R2(predictions, test.data$RecogC)
#)

# save predictions of the model in the new data frame 
# together with variable you want to plot against
#predicted_df <- data.frame(Reco_pred = predict(model.4, BB1), TS.5_mean=BB1$TS.5_mean)

# this is the predicted line of multiple linear regression
#ggplot(data = BB1, aes(x = RecogC, y = TS.5_mean)) + 
 # geom_point(color='blue') +
  #geom_line(color='red',data = predicted_df, aes(x=Reco_pred, y=TS.5_mean))


#plotting model 7
#ggplot(train.data, aes(TS.5_mean, RecogC) ) +
 # geom_point(aes(color = WTH._mean)) +
  #  scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  #theme_bw()

#ggplot(BB1, aes(TS.5_mean, RecogC) ) +
 # geom_point() +
  #  scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  #theme_bw()

#ggplot(BB1, aes(TS.5_mean, RecogC) ) +
 # geom_point(aes(color = WTH._mean)) +
  #  scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  #theme_bw()
```



__BB2__ 

At BB2, including WTH in the model sig. (P<0.05) improves it. BB2 gets significantly drier than BB1, which is why there is such a strong control of WTH on Reco? 

```{r BB2 model reln between Reco and Temp and WTH, figures-side, fig.show="hold", out.width="50%"}
# Polynomial regression: Check for non-linear relationships http://www.sthda.com/english/articles/40-regression-analysis/162-nonlinear-regression-essentials-in-r-polynomial-and-spline-regression-models/

# Build the models
model.1 <- lm(RecogC~ poly(TS.5_mean, 3, raw = TRUE), data = BB2)
model.2 <- lm(RecogC~ poly(TS.5_mean, 2, raw = TRUE), data = BB2)
model.3 <- lm(RecogC~ TS.5_mean, data = BB2)
model.4 <- lm(RecogC~ TS.5_mean + I(TS.5_mean^3)+ WTH._mean, data = BB2) #need to check distribution.. i.e. is it normal? highest R2
model.5 <- lm(RecogC ~ log(TS.5_mean), data = BB2)
model.6 <- lm(log(RecogC) ~ TS.5_mean, data = BB2)
model.7 <- lm(RecogC ~ TS.5_mean + I(TS.5_mean^3), data = BB2) # model with 2nd highest R2

#summ(model.7) # need to check if ols is meeting assumptions
#summ(model.4)

#summary(model.7)
#summary(model.4)

anova(model.7, model.4)

set.seed(123)
training.samples2 <- BB2$RecogC %>%
  createDataPartition(p = 0.8, list = FALSE)
train.data2  <- BB2[training.samples2, ]
test.data2 <- BB2[-training.samples2, ]

# Make predictions
predictions <- model.4 %>% predict(test.data2)

# Model performance
#data.frame(
 # RMSE = RMSE(predictions, test.data2$RecogC),
  #R2 = R2(predictions, test.data2$RecogC)
#)

#not plotting the correct regression here - plotting 
#ggplot(train.data2, aes(TS.5_mean, RecogC) ) +
 # geom_point(aes(color = WTH._mean)) +
  #scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  #theme_bw()

```


When comparing the two sites, note that whilst WTH was not a sig. important predictor for BB1, I have included it in the figure.
In both figures the plotted line does not take into account WTH, but is y ~ x + x^3

```{r compare BB1 and BB2 Reco, figures-side, fig.show="hold", out.width="50%"}
ggplot(BB1, aes(TS.5_mean, RecogC) ) +
  geom_point(aes(color = WTH._mean)) +
  scale_color_gradient(low = "light blue", high = "dark blue")+
  stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  xlab("5cm soil temperature (deg C)")+
  ylab(bquote('Ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
  ggtitle("BB1")+
  theme_bw()

ggplot(BB2, aes(TS.5_mean, RecogC) ) +
  geom_point(aes(color = WTH._mean)) +
  scale_color_gradient(low = "light blue", high = "dark blue")+
  stat_smooth(method = lm, formula = y ~ x + I(x^3))+
  xlab("5cm soil temperature (deg C)")+
  ylab(bquote('Ecosystem respiration (g C' ~m^-2~ day^-1*')'))+
  ggtitle("BB2")+
  theme_bw()
```


__GPP and PAR__

For a given PAR value, GPP is generally higher at BB2 than BB1, suggesting that BB2 has better LUE. 

```{r GPP and PAR, warning = FALSE}
(GPPPAR.p <-Flux.Env %>% 
  ggplot(., aes(PARin_mean, GPP_DT, color = Site)) +
  geom_point()+
   geom_smooth(method = "lm", aes(colour = Site)) +
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  ylab(bquote('GPP (g C' ~m^-2~ day^-1*')'))+
    xlab('PAR')+
    scale_color_aaas()+
  theme_bw())
```


__GPP and NDVI__

Need to think about this more... what is the relationship? 

- When using this with GPP to support each other, could think about above vs. below ground productivity.
- check data? 
- night time filled has -ve GPP valeus? 

```{r GPP and NDVI, figures-side, fig.show="hold", out.width="50%"}
(GPP_DT.NDVI.p <-Flux.Env %>% 
  ggplot(., aes(NDVI_sf, GPP_DT, color = Site)) +
  geom_point()+
   geom_smooth(method = "loess", aes(colour = Site)) +
   ggtitle("Day time filled GPP")+
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  #xlab(bquote('GPP (g C' ~m^-2~ day^-1*')'))+
   # ylab(bquote('Daily' ~CH[4]~ 'flux (g C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())

(GPP_f.NDVI.p <-Flux.Env %>% 
  ggplot(., aes(NDVI_sf, GPP_f, color = Site)) +
  geom_point()+
   geom_smooth(method = "loess", aes(colour = Site)) +
    ggtitle("Night time filled GPP")+
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  #xlab(bquote('GPP (g C' ~m^-2~ day^-1*')'))+
   # ylab(bquote('Daily' ~CH[4]~ 'flux (g C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())
```





### Environmental effects on CH4 fluxes


__CH4 and temperature response__

Non-linear response to temperature. CH4 has a constant added and is log transformed. Response looks fairly similar between sites...

Calculate Q10s for CH4? 


__WTH and CH4__

- WTD : follow instructions from Turetsky in regards to filtering out values so that we are comparing the same things. This will just make is easier to assess the difference in temperature response between the 2 sites, and does not reflect the different in WTD between the sites.

The relationship look non-linear. I will use a similar data analysis technique as shown in fig. 5 of the Turetsky paper: 'Correlation of temperature sensitivity and CH4 flux and the optimal water table position.'

It would be good to plot a timeseries of WTH and CH4 flux as in Brown et al (2014). Also fig. 5 could be a way to plot CH4/WTH/Soil temp relations


```{r CH4 Temp response}
library(car)
Flux.Env <- Flux.Env %>%
  mutate(CH4mgC_RF_log = log(CH4mgC_f_RF + 26))

```

```{r split BB1 and BB2 data}
BB1 <- Flux.Env %>%
  filter(Site == "BB1")

BB2 <- Flux.Env %>%
  filter(Site == "BB2")
```

```{r CH4 temp and WTH response both sites, figures-side, fig.show="hold", out.width="50%"}
#qqPlot(Flux.Env$CH4mgC_RF_log)

#ggplot(data = Flux.Env, aes(CH4mgC_f_RF)) + geom_histogram()
#ggplot(data = Flux.Env, aes(x = TS.5_mean, y = CH4mgC_f_RF)) +
 # geom_point() #+
   #scale_y_log10()

#lmmodel <- lm(log(CH4mgC_f_RF + 26)~TS.5_mean, data = Flux.Env) # use this transformation
#summary(lmmodel)

Temp.logCH4<- Flux.Env %>% #don't need to log transform CH4? 
         #filter(CH4mgC_RF_log > 2) %>%
  ggplot(., aes(TS.5_mean,CH4mgC_RF_log, color= Site)) +
          scale_color_aaas()+
     ylab(bquote('log'~CH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
   xlab('5cm soil temperature (deg C)')+
  geom_point() +
  ggtitle("CH4 ~ Soil temp")+
  theme_bw()
Temp.logCH4


(WTH.logCH4<- Flux.Env %>% #don't need to log transform CH4? 
  filter(#WTH._mean > -12.0,
         logCH4_mgC > 2) %>%
  ggplot(., aes(WTH._mean,CH4mgC_RF_log,  color= Site)) +
          scale_color_aaas()+
     ylab(bquote('log'~CH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
   xlab('WTH (cm)')+
  geom_point() +
    ggtitle(CH4 ~ WTH)+
  theme_bw())
```


WTH is constrained here to be >-20 cm so we can compare the response of CH4 at both sites on a similar scale - sim. to Turetsky paper. 
```{r WTH constrained}
(WTH.logCH42<- Flux.Env %>%  
  filter(WTH._mean > -20.0,
         logCH4_mgC > 2) %>%
  ggplot(., aes(WTH._mean,CH4mgC_RF_log,  color= Site)) +
          scale_color_aaas()+
     ylab(bquote('log'~CH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
   xlab('WTH (cm)')+
  geom_point() +
    ggtitle("CH4 ~ WTH")+
  theme_bw())
```

__BB1__ 

Having the TS * WTH interaction doesn't sig make the model better.

```{r BB1 model reln between CH4 and Temp and WTH}
model.1 <- lm(CH4mgC_RF_log ~ TS.5_mean, data = BB1)
model.2 <- lm(CH4mgC_RF_log ~TS.5_mean + WTH._mean, data = BB1)
model.3 <- lm(CH4mgC_RF_log ~TS.5_mean * WTH._mean, data = BB1)
model.4 <- lm(CH4mgC_RF_log ~ TS.5_mean * poly(WTH._mean, 3, raw = TRUE) , data = BB1)  
model.5 <- lm(CH4mgC_RF_log ~ TS.5_mean + I(WTH._mean ^3) *  WTH._mean, data = BB1) 

#summary(model.2) #going to go with model 2
anova(model.2, model.3)
```


__BB2__

For BB2, including the interaction term does sig improve the models ability to predict CH4 fluxes. 
```{r BB2 model reln between Reco and Temp and WTH}
model.1 <- lm(logCH4_mgC ~ TS.5_mean, data = BB2)
model.2 <- lm(logCH4_mgC ~TS.5_mean + WTH._mean, data = BB2)
model.3 <- lm(logCH4_mgC ~TS.5_mean * WTH._mean, data = BB2)
model.4 <- lm(logCH4_mgC ~ TS.5_mean * poly(WTH._mean, 3, raw = TRUE) , data = BB2)  # same as model 3? but R2 higher? 
model.5 <- lm(logCH4_mgC ~ TS.5_mean + I(WTH._mean ^3) *  WTH._mean, data = BB2) 

#summary(model.3) 
anova(model.2, model.3)
```


- "When the water table is high, CH4 emissions are not regulated by WTD, particularly in vascular plant dominated wetlands... transport of CH4 from sediment to atmosphere via aerenchyma is inhibited by the inundation of AGB of plants" (REF) - from Zhu et al., 2020

```{r compare BB1 and BB2 CH4, figures-side, fig.show="hold", out.width="50%"}
ggplot(BB1, aes(WTH._mean, CH4mgC_RF_log)) +
  geom_point(aes(color = TS.5_mean)) +
  scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = lm, formula = y ~ x+c)+
  xlab("WTH (cm)")+
ylab(bquote('log'~CH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
  ggtitle("BB1")+
  theme_bw()


ggplot(BB2, aes(WTH._mean, CH4mgC_RF_log) ) +
  geom_point(aes(color = TS.5_mean)) +
  scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = 'lm', formula = y ~ x)+
  xlab("WTH (cm)")+
ylab(bquote('log'~CH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
  ggtitle("BB2")+
  theme_bw()
```

```{r BB2 surface plots with CH4, warning=FALSE, echo = FALSE, message = FALSE}
#using tutorial from: http://www.wekaleamstudios.co.uk/posts/creating-surface-plots/#9mzSsIgKCZg

library(geoR)
data("elevation")

BB2$CH4mgC_pred <- 3.293 + (0.047 * BB2$TS.5_mean) + (0.005 * BB2$WTH._mean) - (-0.001 * (BB2$TS.5_mean * BB2$WTH._mean))

BB2.surface <- BB2 %>% select(TS.5_mean, WTH._mean, CH4mgC_f_RF)

BB2.loess <- loess(CH4mgC_f_RF~TS.5_mean*WTH._mean, data = BB2.surface)

BB2.fit <- expand.grid(TS.5_mean = seq(0, 25, 1), WTH._mean = seq(-40, 15, 5))
#BB2.fit[1:20,]
z = predict(BB2.loess, newdata = BB2.fit)
BB2.fit$CH4mgC <- as.numeric(z)

BB2.surf <- wireframe(CH4mgC~TS.5_mean*WTH._mean, data = BB2.fit,
          drape = TRUE,
  colorkey = TRUE,
  scales = list( arrows = FALSE),
   zlab = list("CH4 mgC", rot = 90),
  ylab = list("WTH", rot = 45),
  main = ("BB2"),
   screen = list(z = 160, x = -60))
```

```{r BB1 surface plots with CH4, warning = FALSE, echo = FALSE, message = FALSE}
#using tutorial from: http://www.wekaleamstudios.co.uk/posts/creating-surface-plots/#9mzSsIgKCZg

#summary(lm(CH4mgC_RF_log ~TS.5_mean + WTH._mean, data = BB1))

BB1$CH4mgC_pred <- 3.139 + (0.077 * BB1$TS.5_mean) - (0.028 * BB1$WTH._mean)

BB1.surface <- BB1 %>% select(TS.5_mean, WTH._mean, CH4mgC_f_RF)

BB1.loess <- loess(CH4mgC_f_RF~TS.5_mean*WTH._mean, data = BB1.surface)

BB1.fit <- expand.grid(TS.5_mean = seq(0, 25, 1), WTH._mean = seq(-40, 15, 5))
#BB1.fit[1:20,]
z = predict(BB1.loess, newdata = BB1.fit)
BB1.fit$CH4mgC <- as.numeric(z)

BB1.surf <- wireframe(CH4mgC~TS.5_mean*WTH._mean, data = BB1.fit,
          drape = TRUE,
  colorkey = TRUE,
  scales = list( arrows = FALSE),
  zlab = list("CH4 mgC", rot = 90),
  ylab = list("WTH", rot = 45),
  main = "BB1",
   screen = list(z = 160, x = -60))

###Look into 3D plot for other surface plotting options
```


```{r both surface plots, figures-side, fig.show="hold", out.width="50%"}
BB1.surf

BB2.surf
```

```{r CH4 model testing - not using, eval=FALSE, include=FALSE}
#library(AER)

# fit a simple linear model
#linear_model<- lm(logCH4_mgC ~ TS.5_mean*WTH._mean, data = BB1)
#summary(linear_model)

# fit the quadratic Model
#quadratic_model.1 <- glm(logCH4_mgC~ TS.5_mean + I(TS.5_mean^2) + WTH._mean, data = BB1)
#quadratic_model.2 <- glm(logCH4_mgC~ TS.5_mean + I(TS.5_mean^2)+ I(TS.5_mean^3) + WTH._mean, data = BB1) #this one is better, but can it be better? When to include extra variables? 
#quadratic_model.3 <- glm(logCH4_mgC ~ poly(TS.5_mean, 3, raw = TRUE) + WTH._mean, data = BB1) #this is the same as model 2

#summ(quadratic_model.2)

# obtain the model summary
#coeftest(quadratic_model.2, vcov. = vcovHC, type = "HC1")

# draw a scatterplot of the observations for income and test score
#plot(BB1$TS.5_mean, BB1$logCH4_mgC,
 #    col  = "steelblue",
  #   pch = 20,
   #  xlab = "TS.5_mean",
    # ylab = "logCH4_mgC",
    # main = "Estimated Linear and Quadratic Regression Functions")

# add a linear function to the plot
#abline(linear_model, col = "black", lwd = 2)

# add quatratic function to the plot
#order_id <- order(BB1$TS.5_mean)

#lines(x = BB1$TS.5_mean[order_id], 
 #     y = fitted(quadratic_model.2)[order_id],
  #    col = "red", 
   #   lwd = 2) 

### finished here 15th feb
#BB1.model$CH4.pred <- 4.88 - .24*(BB1.model$TS.5_mean) + 0.013*(I(BB1.model$TS.5_mean^2)) - 0.036*(BB1.model$WTH)
#plot(BB1.model$CH4.pred, BB1.model$logCH4_mgC)
#lm.1 <- lm(CH4.pred~logCH4_mgC, data = BB1.model)
#summary(lm.1)

#USE THIS 30/11/2020#
#ggplot(BB1, aes(TS.5_mean, logCH4_mgC))+geom_point() +
 # geom_smooth(method = "gam", formula = y ~ x + I(x^2))

#ggplot(BB1.model, aes(TS.5_mean, logCH4_mgC))+geom_point() +
 #    geom_line(aes(y = CH4.pred), size = 1)
#quadratic_model.3 <- glm(logCH4_mgC ~ poly(TS.5_mean, 3, raw = TRUE) + WTH._mean, data = BB1) #this is the same as model 2


#set.seed(123)
#training.samples.ch4 <- BB1$CH4_mgC %>%
 # createDataPartition(p = 0.8, list = FALSE)
#train.data2.ch4  <- BB1[training.samples2, ]
#test.data2.ch4 <- BB1[-training.samples2, ]

# Make predictions
#predictions <- quadratic_model.3 %>% predict(test.data2.ch4)

# Model performance
#data.frame(
 # RMSE = RMSE(predictions, test.data2.ch4$CH4_mgC),
  #R2 = R2(predictions, test.data2.ch4$CH4_mgC)
)

#I'm not plotting the correct regression line here...
#ggplot(train.data2.ch4, aes(TS.5_mean, CH4_mgC) ) +
 # geom_point(aes(color = WTH._mean)) +
  #scale_color_gradient(low = "light blue", high = "dark blue")+
  #stat_smooth(method = glm, formula = y ~ x + I(x^3) + WTH._mean)+
  #theme_bw()
```



### CH4 and CO2 relationships

__CH4 emissions and C sequestration__

- need to ask whether GPP is a significant driving factor for CH4 emissions (Fig 2 from Hemes paper)

- It seems that for a given value of NEE <0, BB1 produces more CH4 than BB1 - maybe this could mean that at BB1, WTH is more important than the influence of vascular veg....  At BB2, more vascular vegetation, driven by lower water tables, means that CH4 emissions are lower. This is surprising because I would've thought that more labile substrate from vascular veg --> more ch4 emissions, considering I dont think the SWC is limiting...

- Below both sites are plotted differently and it looks like there are differences between their relationships.

```{r CH4 emissions and C sequestration}
(CH4.Cseq.p <-Flux.Env %>% 
  ggplot(., aes(NEE_f, CH4mgC_RF_log, color = Site)) +
  geom_point()+
   geom_smooth(method = "glm", aes(colour = Site)) +
  scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  xlab(bquote('NEE (g C' ~m^-2~ day^-1*')'))+
    ylab(bquote('Daily' ~logCH[4]~ 'flux (g C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())
```



```{r CH4 emissions and C sequestration BB1 and BB2 sep, figures-side, fig.show="hold", out.width="50%"}
CH4.GPPBB1 <- lm(CH4mgC_RF_log~NEE_f * TS.5_mean * WTH._mean, BB1)
#summary(CH4.GPPBB1)

(CH4.Cseq.p1 <- ggplot(BB1, aes(NEE_f, CH4mgC_RF_log)) +
  geom_point()+
   #geom_smooth(method = "lm", aes(colour = Site)) +
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  xlab(bquote('NEE (g C' ~m^-2~ day^-1*')'))+
    ylab(bquote('Daily' ~logCH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())

CH4.GPPBB2 <- lm(CH4mgC_RF_log~NEE_f *TS.5_mean*WTH._mean, BB2)
#summary(CH4.GPPBB2)

(CH4.Cseq.p1 <- ggplot(BB2, aes(NEE_f, CH4mgC_RF_log)) +
  geom_point()+
   #geom_smooth(method = "lm", aes(colour = Site)) +
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  xlab(bquote('NEE (g C' ~m^-2~ day^-1*')'))+
    ylab(bquote('Daily' ~logCH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())
```



```{r ch4 hysteresis with soil temp}
(CH4.soilT.hys <- ggplot(Flux.Env, aes(TS.5_mean, CH4mgC_RF_log)) +
  geom_point(aes(shape = Period, color = Site), size = 3)+
   #geom_smooth(method = "lm", aes(colour = Site)) +
  #scale_colour_manual(values = c("#0072B2", "#D55E00")) +
  xlab('Soil temperature')+
    ylab(bquote('Daily' ~logCH[4]~ 'flux (mg C' ~m^-2~ day^-1*')'))+
    scale_color_aaas()+
  theme_bw())
```
